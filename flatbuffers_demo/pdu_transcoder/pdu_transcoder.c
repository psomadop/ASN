#include "pdu_transcoder.h"
#include "pdu_builder.h" // Generated by `flatcc`.
#include "pdu_reader.h"  // Generated by 'flatcc'.
#include "assert.h"

// Convenient namespace macro to manage long namespace prefix.
#undef ns
#define ns(x) FLATBUFFERS_WRAP_NAMESPACE(GTP, x) // Specified in the schema.
// A helper to simplify creating vectors from C-arrays.
#define c_vec_len(V) (sizeof(V)/sizeof((V)[0]))

/**
 * ASN.1 Encode tx_pdu, to the supplied buffer of specified length.
 *
 * @param   tx_pdu          TX_PDU structure to encode to ASN.1 binary format.
 * @param   buffer          Byte buffer where encoded TX_PDU will be stored.
 * @param   buffer_size     Size of supplied buffer.
 * @param   enc_len         Will contain the number of encoded bytes, on success.
 *
 * @return  encoded bytes   On success, the number of encoded bytes is returned.
 *          -1              On failure.
 */
int pdu_encode(TX_PDU* tx_pdu, char* buffer, int buffer_size, int *enc_len)
{
    int i, status, ret;
    flatcc_builder_t builder, *B;
    B = &builder;
    // Initialize the builder object.
    flatcc_builder_init(B);

    GTP_Cell_ref_t fcell;
    GTP_PDU_ref_t fpdu;
    GTP_ComplexType_ref_t fmessage = GTP_ComplexType_create(B, 0,
            flatbuffers_int32_vec_create(B, NULL, 0 * sizeof(int)));

    /**
     * I need a vector to store flatbuffer Cells.
     * These will be converted to a flatbuffers vector.
     */
    GTP_Cell_vec_start(B);

    for (i = 0; i < tx_pdu->num_cells; i++)
    {
        CELL *cur = &tx_pdu->cells[i];
        
        switch (cur->type)
        {
            case CELL_TYPE_INT:
                fcell = GTP_Cell_create(B, GTP_CellType_INT, cur->u.int_val, 0, 0, fmessage);
                assert(fcell);
                break;

            case CELL_TYPE_BOOL:
                fcell = GTP_Cell_create(B, GTP_CellType_BOOL, 0, cur->u.bool_val, 0, fmessage);
                assert(fcell);
                break;

            case CELL_TYPE_NAME:
                fcell = GTP_Cell_create(B, GTP_CellType_NAME, 0, 0, flatbuffers_string_create_str(B, cur->u.name_val) , fmessage);
                assert(fcell);
                break;

            case CELL_TYPE_MESSAGE:
                fmessage = GTP_ComplexType_create(
                        B, cur->u.message.clock_ticks,
                        flatbuffers_int32_vec_create(B, cur->u.message.integers, 4 * sizeof(int)));
                assert(fmessage);

                fcell = GTP_Cell_create(B, GTP_CellType_NAME, 0, 0, 0, fmessage);
                assert(fcell);
                break;
        }

        GTP_Cell_vec_push(B, fcell);
    }

    GTP_Cell_vec_ref_t fcells = GTP_Cell_vec_end(B);
    assert(fcells);

    fpdu = GTP_PDU_create_as_root(B, fcells);
    assert(fpdu);

    *enc_len = 0;
    /* ENCODE */
    uint8_t* buf = flatcc_builder_finalize_buffer(B, (size_t*)enc_len);

    if (*enc_len == 0)
    {
        ret = -1;
    }
    else
    {
        ret = *enc_len;
        memcpy(buffer, buf, *enc_len);
    }

    flatcc_builder_clear(B);
    return ret;
}


/**
 * Decode ASN.1 encoded buffer to supplied TX_PDU structure;
 *
 * @param   tx_pdu          TX_PDU structure with decoded data.
 * @param   buffer          Byte buffer where encoded TX_PDU is be stored.
 * @param   buffer_size     Size of supplied buffer.
 *
 * @return  Consumed bytes  On success, the number of bytes consumed from buffer is returned.
 *          -1              On failure.
 */
int pdu_decode(TX_PDU* tx_pdu, char* buffer, int buffer_size)
{
    GTP_PDU_table_t fpdu = GTP_PDU_as_root(buffer);
    GTP_Cell_vec_t fcells = GTP_PDU_cells(fpdu);
    GTP_CellType_enum_t ftype;
    int     i,ret,num_cells;

    num_cells = GTP_Cell_vec_len(fcells);
    printf("num cells decoded %d\n", num_cells);
    for (i = 0; i < num_cells; i++)
    {

    }


    return 1;
}
